use anyhow::Result;
use clap::{Parser, Subcommand};
use colored::*;
use std::process::{Command, Stdio};
use std::time::Instant;

#[derive(Parser)]
#[command(name = "xtask")]
#[command(about = "Development automation for echo-core")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Run all CI checks (fmt, clippy, build, test)
    Ci {
        #[arg(long)]
        verbose: bool,
    },
    /// Quick checks before commit (fmt, clippy)
    Check {
        #[arg(long)]
        verbose: bool,
    },
    /// Format code
    Fmt {
        #[arg(long)]
        check: bool,
    },
    /// Run clippy
    Clippy {
        #[arg(long)]
        fix: bool,
    },
    /// Build the project
    Build {
        #[arg(long)]
        release: bool,
    },
    /// Run tests
    Test {
        #[arg(long)]
        doc: bool,
        #[arg(long)]
        ignored: bool,
    },
    /// Run benchmarks
    Bench,
    /// Pre-commit hook (fmt, clippy, test)
    PreCommit,
    /// Install git hooks
    InstallHooks,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Ci { verbose } => run_ci(verbose),
        Commands::Check { verbose } => run_check(verbose),
        Commands::Fmt { check } => run_fmt(check),
        Commands::Clippy { fix } => run_clippy(fix),
        Commands::Build { release } => run_build(release),
        Commands::Test { doc, ignored } => run_test(doc, ignored),
        Commands::Bench => run_bench(),
        Commands::PreCommit => run_pre_commit(),
        Commands::InstallHooks => install_hooks(),
    }
}

fn run_ci(verbose: bool) -> Result<()> {
    println!("{}", "=== Running CI Pipeline ===".bold().blue());

    let start = Instant::now();

    run_task("Format Check", || run_fmt(true), verbose)?;
    run_task("Clippy", || run_clippy(false), verbose)?;
    run_task("Build", || run_build(false), verbose)?;
    run_task("Test", || run_test(false, false), verbose)?;

    let elapsed = start.elapsed();
    println!(
        "\n{} {}",
        "✓ CI passed in".green().bold(),
        format!("{:.2}s", elapsed.as_secs_f64()).bold()
    );

    Ok(())
}

fn run_check(verbose: bool) -> Result<()> {
    println!("{}", "=== Running Quick Checks ===".bold().blue());

    let start = Instant::now();

    run_task("Format Check", || run_fmt(true), verbose)?;
    run_task("Clippy", || run_clippy(false), verbose)?;

    let elapsed = start.elapsed();
    println!(
        "\n{} {}",
        "✓ Checks passed in".green().bold(),
        format!("{:.2}s", elapsed.as_secs_f64()).bold()
    );

    Ok(())
}

fn run_fmt(check: bool) -> Result<()> {
    let mut cmd = Command::new("cargo");
    cmd.arg("fmt").arg("--all");

    if check {
        cmd.arg("--").arg("--check");
    }

    execute_command(&mut cmd)
}

fn run_clippy(fix: bool) -> Result<()> {
    let mut cmd = Command::new("cargo");
    cmd.arg("clippy").arg("--all-targets").arg("--all-features");

    if fix {
        cmd.arg("--fix");
    } else {
        cmd.arg("--").arg("-D").arg("warnings");
    }

    execute_command(&mut cmd)
}

fn run_build(release: bool) -> Result<()> {
    let mut cmd = Command::new("cargo");
    cmd.arg("build");

    if release {
        cmd.arg("--release");
    }

    execute_command(&mut cmd)
}

fn run_test(doc: bool, ignored: bool) -> Result<()> {
    let mut cmd = Command::new("cargo");
    cmd.arg("test").arg("--all-features");

    if doc {
        cmd.arg("--doc");
    }

    if ignored {
        cmd.arg("--").arg("--ignored");
    }

    execute_command(&mut cmd)
}

fn run_bench() -> Result<()> {
    let mut cmd = Command::new("cargo");
    cmd.arg("bench");

    execute_command(&mut cmd)
}

fn run_pre_commit() -> Result<()> {
    println!("{}", "=== Pre-commit Checks ===".bold().blue());

    let start = Instant::now();

    run_task("Format", || run_fmt(false), false)?;
    run_task("Clippy", || run_clippy(false), false)?;
    run_task("Test", || run_test(false, false), false)?;

    let elapsed = start.elapsed();
    println!(
        "\n{} {}",
        "✓ Pre-commit checks passed in".green().bold(),
        format!("{:.2}s", elapsed.as_secs_f64()).bold()
    );

    Ok(())
}

fn install_hooks() -> Result<()> {
    use std::fs;

    println!("{}", "Installing git hooks...".bold());

    let hook_content = r#"#!/bin/sh
# Auto-generated by cargo xtask install-hooks
set -e

echo "Running pre-commit checks..."
cargo xtask pre-commit
"#;

    let hook_path = ".git/hooks/pre-commit";
    fs::write(hook_path, hook_content)?;

    // Make executable (Unix only)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;

        let mut perms = fs::metadata(hook_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(hook_path, perms)?;
    }

    println!("{}", "✓ Git hooks installed".green());
    println!("  Pre-commit hook will run: fmt, clippy, test");

    Ok(())
}

fn run_task<F>(name: &str, task: F, verbose: bool) -> Result<()>
where
    F: FnOnce() -> Result<()>,
{
    print!("{} {} ... ", "→".blue(), name);

    let start = Instant::now();

    match task() {
        Ok(_) => {
            let elapsed = start.elapsed();
            println!(
                "{} {}",
                "✓".green().bold(),
                if verbose {
                    format!("({:.2}s)", elapsed.as_secs_f64())
                } else {
                    String::new()
                }
            );
            Ok(())
        }
        Err(e) => {
            println!("{}", "✗".red().bold());
            Err(e)
        }
    }
}

fn execute_command(cmd: &mut Command) -> Result<()> {
    let status = cmd
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()?;

    if !status.success() {
        anyhow::bail!("Command failed with exit code: {}", status);
    }

    Ok(())
}
