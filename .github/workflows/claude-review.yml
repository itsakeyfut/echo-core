name: Claude Code Review (Manual)

# This workflow is manually triggered from GitHub Actions UI or gh CLI
# Contributors provide their own API key when triggering the review

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number
      api_key:
        description: 'Your Claude API key (sk-ant-api03-...)'
        required: true
        type: string

jobs:
  claude-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: read
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Validate API Key Format
      run: |
        if [[ ! "${{ github.event.inputs.api_key }}" =~ ^sk-ant- ]]; then
          echo "‚ùå Invalid API key format. Must start with 'sk-ant-'"
          exit 1
        fi
        echo "‚úÖ API key format validated"

    - name: Get PR info
      id: pr_info
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ github.event.inputs.pr_number }}
          });

          return {
            title: pr.title,
            body: pr.body,
            base: pr.base.ref,
            head: pr.head.ref,
            sha: pr.head.sha
          };

    - name: Delete previous Claude comments
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: ${{ github.event.inputs.pr_number }}
          });

          const claudeComments = comments.filter(comment =>
            comment.user.login === 'github-actions[bot]' &&
            comment.body.includes('ü§ñ AI Code Review - PSRX')
          );

          for (const comment of claudeComments) {
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: comment.id
            });
          }

    - name: Extract issue numbers
      id: extract_issues
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const prInfo = ${{ steps.pr_info.outputs.result }};
          const prText = `${prInfo.title}\n${prInfo.body || ''}`;

          const issueMatches = prText.match(/#\d+/g) || [];
          const issueNumbers = [...new Set(issueMatches.map(match => match.substring(1)))];

          return issueNumbers;

    - name: Fetch issue content
      id: fetch_issues
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issueNumbers = ${{ steps.extract_issues.outputs.result }};
          const issues = [];

          for (const issueNumber of issueNumbers) {
            try {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumber)
              });

              issues.push({
                number: issueNumber,
                title: issue.title,
                body: issue.body || '',
                labels: issue.labels.map(l => l.name)
              });
            } catch (error) {
              console.log(`Could not fetch issue #${issueNumber}`);
            }
          }

          return issues;

    - name: Run Claude Code Review
      id: claude_review
      uses: anthropics/claude-code-action@beta
      with:
        # Use the API key provided in workflow input
        claude_code_oauth_token: ${{ github.event.inputs.api_key }}
        github_token: ${{ secrets.GITHUB_TOKEN }}
        anthropic_model: "claude-sonnet-4-5-20250929"
        timeout_minutes: 15
        mode: agent
        direct_prompt: |
          # Code Review for PSRX PlayStation 1 Emulator

          ## Project Overview
          PSRX is a PlayStation 1 (PS1/PSX) emulator written in Rust, focusing on accuracy and performance.
          The emulator implements the MIPS R3000A CPU, GPU, SPU, and various peripherals of the original hardware.

          ## Referenced Issues
          ${{ steps.fetch_issues.outputs.result }}

          ## Review Criteria

          ### 1. PlayStation 1 Hardware Accuracy
          - **CPU (MIPS R3000A)**
            - Instruction implementation correctness (compare with MIPS I ISA spec)
            - Delay slot handling
            - Exception handling (interrupts, traps, syscalls)
            - Coprocessor 0 (System Control) registers
          - **Memory Architecture**
            - Address mapping (KUSEG, KSEG0, KSEG1, KSEG2)
            - Cache behavior simulation (if implemented)
            - Memory mirroring (RAM mirrors at different addresses)
          - **GPU (Geometry Transformation Engine + Rasterizer)**
            - Drawing commands (polygons, lines, sprites)
            - VRAM access patterns
            - Display modes and timing
          - **SPU (Sound Processing Unit)**
            - ADPCM decoding
            - Voice management
            - Reverb effects
          - **Peripherals**
            - CD-ROM controller (sector reading, seeking)
            - DMA channels
            - Timers and interrupts
            - Controller input

          ### 2. Rust Language Best Practices
          - **Ownership & Borrowing**
            - Minimal cloning (use references where possible)
            - Lifetime annotations for complex structures
            - Smart pointer usage (`Box`, `Rc`, `Arc`)
          - **Type Safety**
            - Newtype pattern for hardware addresses
            - Strong typing for register values
            - Enum for hardware states
          - **Error Handling**
            - `Result<T, E>` for fallible operations
            - `Option<T>` for nullable values
            - Custom error types with `thiserror` or similar
            - Avoid `unwrap()` in production code (use `expect()` with clear messages)
          - **Performance**
            - Avoid unnecessary allocations in hot paths
            - Use `const` for compile-time constants
            - Consider `inline` for small frequently-called functions
            - Profile-guided optimization hints
          - **Unsafe Code**
            - Justify all `unsafe` usage with comments
            - Ensure memory safety invariants
            - Prefer safe abstractions

          ### 3. Emulation-Specific Concerns
          - **Timing Accuracy**
            - Cycle counting for CPU instructions
            - Clock synchronization between components
            - Proper interrupt timing
          - **State Management**
            - Save state support (serialization)
            - Clean separation of emulator state
          - **Debugging Support**
            - Disassembler output accuracy
            - Logging for debugging without performance impact
            - Debugging tools integration

          ### 4. Code Quality
          - **Naming Conventions**
            - `snake_case` for functions, variables, modules
            - `PascalCase` for types, traits, enums
            - `SCREAMING_SNAKE_CASE` for constants
            - Hardware-specific names should match official documentation
          - **Documentation**
            - Public API documentation with examples
            - Complex algorithms explained (WHY, not just WHAT)
            - Hardware references cited (e.g., "Nocash PSX Specs")
          - **Magic Numbers**
            - Replace with named constants
            - Include hardware addresses in comments
          - **Testing**
            - Unit tests for individual components
            - Integration tests for subsystems
            - Test edge cases and error conditions
            - Consider test ROMs for validation

          ### 5. Issue Specification Compliance
          If related issues are referenced:
          - All acceptance criteria met
          - Implementation matches the intended behavior
          - No scope creep or unrelated changes

          ## Output Format

          ```markdown
          # ü§ñ AI Code Review - PSRX

          ## üìã Review Checklist
          - [x] Rust language best practices
          - [x] PS1 hardware accuracy
          - [x] Error handling
          - [x] Test coverage
          - [x] Documentation
          - [x] Performance considerations
          - [x] Safety (unsafe code review)

          ## üìä Overall Assessment

          **Score:** X/10

          **Summary of Changes:**
          [1-2 sentence description of what this PR does]

          ## üéØ Issue Specification Compliance

          <details open>
          <summary><b>Verification of Issue #XX</b></summary>

          **Requirements:**
          - [Requirement 1]: ‚úÖ Implemented / ‚ùå Missing / ‚ö†Ô∏è Partial

          **Acceptance Criteria:**
          - [ ] AC1: [Result]
          - [ ] AC2: [Result]

          </details>

          ## üîç Issues by Priority

          ### üî¥ Critical (Must Fix)
          [Severe issues that must be fixed before merge]

          1. **[Brief description]**
             - Location: `src/path/file.rs:123`
             - Issue: [Detailed explanation]
             - Impact: [Potential bugs or undefined behavior]
             - Suggested Fix:
               ```rust
               // Corrected code
               ```

          ### üü° High (Should Fix)
          [Important issues that should be addressed]

          ### üü† Medium (Nice to Have)
          [Moderate issues worth considering]

          ### üü¢ Low (Minor)
          [Minor issues, optional fixes]

          ## üí° Specific Improvement Suggestions

          ### Suggestion 1: [Title]
          **Current Code:**
          ```rust
          // Problematic code
          ```

          **Suggested Improvement:**
          ```rust
          // Improved code
          ```

          **Rationale:** [Why this is better]

          ## ‚ú® Positive Highlights

          - [Specific good practice 1]
          - [Specific good practice 2]

          ## üéÆ PlayStation 1 Hardware Accuracy

          - [Assessment of hardware implementation accuracy]
          - [Comparison with reference documentation if applicable]

          ## üìà Test Coverage

          - Unit tests: [Assessment]
          - Edge cases: [Assessment]
          - Integration tests: [Assessment]

          ## üîí Safety Review

          - Unsafe code usage: [Assessment]
          - Panic conditions: [Assessment]
          - Overflow handling: [Assessment]

          ## üìù Documentation

          - Public API docs: [Assessment]
          - Inline comments: [Assessment]
          - Hardware references: [Assessment]

          ## üéØ Final Verdict

          [Overall evaluation and final comments]
          ```

          ## Important Guidelines

          1. **Code examples must use correct Rust syntax**
          2. **Markdown code blocks must be properly closed**
          3. **Provide specific file paths and line numbers**
          4. **Be critical but constructive**
          5. **Always highlight positive aspects too**
          6. **Score strictly (5-7 is average, 8+ is excellent)**
          7. **Consider PS1 hardware documentation accuracy**
          8. **Flag any deviation from PS1 hardware behavior**

          All review comments must be written in **English** for international collaboration.

    - name: Check review quality gate
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          await new Promise(resolve => setTimeout(resolve, 3000));

          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: ${{ github.event.inputs.pr_number }}
          });

          const claudeComment = comments
            .filter(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('ü§ñ AI Code Review')
            )
            .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

          if (!claudeComment) {
            console.log('‚ö†Ô∏è Claude review comment not found.');
            return;
          }

          const reviewBody = claudeComment.body;
          const scoreMatch = reviewBody.match(/\*\*Score:\*\*\s*(\d+(?:\.\d+)?)\s*\/\s*10/);
          const score = scoreMatch ? parseFloat(scoreMatch[1]) : null;

          console.log(`üìä Review Score: ${score !== null ? score + '/10' : 'Not found'}`);

          const MIN_SCORE = 7.0;

          if (score !== null && score < MIN_SCORE) {
            const failureMessage = [
              '## ‚ö†Ô∏è Code Review Quality Gate',
              '',
              `üìä Score: ${score}/10 (threshold: ${MIN_SCORE}/10)`,
              '',
              '### Recommended Actions:',
              '- Review and address critical/high priority issues',
              `- Improve code quality to achieve at least ${MIN_SCORE}/10`,
              '',
              'üí° This is a recommendation, not a blocker. Human reviewers make the final decision.',
              '',
              `Full review: ${claudeComment.html_url}`,
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.inputs.pr_number }},
              body: failureMessage
            });

            console.log('‚ö†Ô∏è Quality gate threshold not met, but not blocking merge');
          } else {
            console.log('‚úÖ Quality gate passed!');

            const successMessage = [
              '## ‚úÖ Code Review Quality Gate Passed',
              '',
              score !== null ? `**Score:** ${score}/10 ‚ú®` : '**Status:** Passed',
              '',
              `Full review: ${claudeComment.html_url}`,
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.inputs.pr_number }},
              body: successMessage
            });
          }